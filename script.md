**Фибоначчиева куча** (также известная как Фибоначчиева куча-дерево или Фибоначчиева пирамида) - это структура данных, которая является вариантом двоичной кучи. В отличие от двоичной кучи, в которой каждый узел имеет не более двух детей, каждый узел Фибоначчиевой кучи может иметь произвольное число детей.

## **СЛАЙД 2. История**
Фибоначчиева куча была впервые предложена Майклом Фредманом и Робертом Тарьяном в 1984 году. Эта структура данных названа в честь математика Леонардо Фибоначчи, который разработал последовательность чисел, известную как "фибоначчиева последовательность".

Первоначально Фредман и Тарьян использовали Фибоначчиеву кучу для решения проблемы поиска минимального остовного дерева в графах. Они заметили, что Фибоначчиева куча обеспечивает эффективный способ выполнения таких операций, как нахождение минимального элемента, объединение двух куч и вставка новых элементов.

С тех пор Фибоначчиева куча была широко применена в различных областях, таких как алгоритмы оптимизации, базы данных, сетевые протоколы и многие другие. В настоящее время Фибоначчиева куча продолжает быть активной областью исследований, и появляются новые модификации и улучшения этой структуры данных.

## **СЛАЙД 3. Основные методы**
Основные методы работы с Фибоначчиевой кучей включают:

* Вставка: Для вставки нового элемента в кучу, мы просто создаем новый узел и добавляем его в корень кучи. Затем объединяем двух соседних узлов, если они имеют одинаковую степень.

* Удаление минимального элемента: Когда нужно удалить минимальный элемент из кучи, мы сначала удаляем корень кучи и делаем все его дочерние узлы корнями отдельных поддеревьев. Затем мы объединяем эти поддеревья, чтобы получить новую кучу.

* Объединение: Чтобы объединить две Фибоначчиевы кучи в одну, мы просто связываем корни этих двух куч и выбираем новый корень, который является минимальным элементом из двух куч.

* Уменьшение ключа: Если мы хотим уменьшить значение ключа в узле кучи, мы сначала сделаем это изменение, а затем проверим свойства кучи и, если эти свойства нарушены, перестроим кучу.

* Удаление произвольного элемента: Чтобы удалить произвольный элемент из Фибоначчиевой кучи, мы сначала находим его и удаляем. Затем мы объединяем дочерние узлы этого элемента, чтобы получить новую кучу.

Фибоначчиева куча обычно используется там, где требуется быстрое выполнение операций вставки, удаления и нахождения минимального элемента. Она также может быть использована для решения определенных задач, таких как поиск минимального остовного дерева в графе.

## **Добавление**
Давайте рассмотрим этот алгоритм на конкретном примере. Будем добавлять в Фибоначчиеву кучу элементы массива `[5, 1, 3, 2, 4, 0, 7, 6]`.

**СЛАЙД 4** В начальный момент куча пуста и в ней нет ни одного дерева.

**СЛАЙД 5** Новый элемент `5` становится корнем единственного дерева и, само собой, минимальным элементом всей кучи.

**СЛАЙД 6** Затем элемент `1` образует новое дерево и становится минимальным.

Каждый новый добавленный элемент будет образовывать новое дерево, а его корень будет добавлять в кольцевой список корней.

**СЛАЙД 7** Добавляем `3` справа от минимального элемента.

**СЛАЙД 8** Элемент `2` встает справа от минимального элемента.

**СЛАЙД 9** Элемент `4` аналогично встает справа от `1`.

**СЛАЙД 10** Элемент `0` становится новым минимальным элементов и так же добавляется справа от предыдущего минимального элемента.

**СЛАЙД 11** Оставшиеся элементы аналогично добавляются в Фибоначчиеву кучу. Очевидно, что данная операция занимает `O(1)`.

## **СЛАЙД 12. Определение минимального элемента**
Данная операция совершается за `O(1)`, так как мы уже заведомо всегда храним указатель на минимальный элемент кучи.

## **СЛАЙД 13. Объединение двух куч**
Операция объединения двух Фибоначчиевых куч занимает `O(1)` благодаря особенностям структуры Фибоначчиевой кучи.

Фибоначчиева куча представляет собой набор деревьев, упорядоченных по ключам. Каждый узел дерева содержит ссылку на своих братьев и родителя, а также список своих детей. Дерево является кучей минимальных значений, то есть ключ корня меньше всех ключей его потомков.

При объединении двух Фибоначчиевых куч происходит соединение корней двух куч в один список. Затем происходит объединение списка детей корней второй кучи со списком детей корня первой кучи. После этого выбирается новый корень, который будет иметь наименьший ключ из обоих корней. Этот процесс не требует перестройки деревьев или других сложных операций, поэтому время выполнения операции составляет `O(1)`.

## **СЛАЙД 14. Удаление минимального элемента**
Эта операция является наиболее трудоемкой, занимающая `O(logn)`. Поэтому ее описание разобьем на несколько этапов:
1. Если минимальный элемент имеет детей, то их необходимо сделать корневыми узлами.
2. Удаляем минимальный элемент из кольцевого списка корней. Для этого нужно грамотно перебросить ссылочки с левого и правого брата. При этом новым минимальным элементом кучи на время становится правый брат удаляемого элемента. Не факт, что правый брат является минимальным узлом, но после окончания функции будет найден корректный минимальный узел.
3. Процесс уплотнения кучи (consolidate) лучше понять на иллюстрации кучи.

Рассмотрим на примере.

**СЛАЙД 15** После удаления минимального элемента “0” текущим элементом становится правый его брат “6”, образую первое фибоначчиево дерево размером 1.
**СЛАЙД 16** Переходим к правому брату элемента “6”, т.е. к “7”, который образует дерево размером 1. Но на предыдущем шаге уже было получено дерево с таким размером. Объединяем их
**СЛАЙД 17** При слиянии двух деревьев “6” и “7” минимальный корень двух деревьев становится общим корнем. А корень второго дерева становится сыном общего корня. После чего образуется новое дерево размером 2 – “6-7”. Увеличиваем счетчик детей у элемента “2”.
**СЛАЙД 18** Следующим элементом становится “4”, образуя дерево размером 1. На текущем шаге имеется одно дерево размером 2 и одно дерево размером 1. Поэтому сливать деревья не надо
**СЛАЙД 19** Новое дерево “2” имеет тот же размер, что и дерево “4”. Сливаем их.
**СЛАЙД 20** После слияния получается дерево “2-4” размером 2. Но у нас уже есть дерево размером 2 – “6-7”. Поэтому сливаем сливаем эти деревья
**СЛАЙД 21** При слиянии деревьев на предыдущем шаге образуется дерево размером 4, корнем которого является элемент “2”. Элемент “6” становится сыном элемента “2”. На рисунке нет явной связи “2” и “6”, потому что “6” включена в циклический список с “4”, который является сыном “2”.
**СЛАЙД 22** Новое дерево “3” имеет уникальную размерность
**СЛАЙД 23** Далее рассуждения можно продолжить по аналогии с предыдущими шагами.

## **СЛАЙД 25-26 Тесты**
Сейчас на экране вы можете видеть результаты замеров количества итераций и времени на каждый алгоритм. Данные графики были построены с помощью Matplotlib.

## **СЛАЙД 27 Выводы**
Что ж, давайте проведем некоторые выводы насчет нашей структуры данных.

Фибоначчиева куча имеет ряд преимуществ и недостатков.

Плюсы:

1. Вставка элементов в Фибоначчиеву кучу выполняется за время O(1), поскольку новый узел просто добавляется в список корней.
2. Объединение двух Фибоначчиевых куч также выполняется за время O(1), что позволяет эффективно поддерживать множество элементов.
3. Фибоначчиева куча хранит дополнительную информацию о степени каждого узла, что упрощает операцию удаления минимального элемента.
4. Фибоначчиева куча поддерживает технику отложенной каскадной настройки, которая улучшает производительность при выполнении нескольких операций объединения или удаления.

Минусы:

1. Фибоначчиева куча требует дополнительных вычислений для поддержания инвариантов структуры данных, которые приходится выполнять после каждой операции вставки, удаления или объединения.
2. Каждый узел Фибоначчиевой кучи содержит больше информации, чем узел в других структурах данных, что увеличивает использование памяти.
3. Фибоначчиева куча не всегда является самой быстрой структурой данных для всех операций, и в некоторых случаях другие структуры данных, такие как красно-черное дерево или куча на основе двоичной кучи, могут быть более эффективными.

В целом, Фибоначчиева куча является эффективной структурой данных, которая может быть полезна при работе с большими объемами данных, но её применение следует рассматривать в контексте конкретных задач и требований производительности.

## **СЛАЙД 28. Литература**
Список использованной литературы и ссылку на репозиторий с кодом вы можете видеть на своем экране.

## **СЛАЙД 29. Спасибо за внимание**